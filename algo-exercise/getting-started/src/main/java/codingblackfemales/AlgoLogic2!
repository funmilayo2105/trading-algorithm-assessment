@Override
public Action evaluate(SimpleAlgoState state) {
    if (state == null) {
        logger.error("[MYALGO] Received null state.");
        return NoAction.NoAction;
    }

    var orderBookAsString = Util.orderBookToString(state);
    logger.info("[MYALGO] The state of the order book is:\n" + orderBookAsString);

    // Initialize risk management with parameters
    if (riskManagement == null) {
        this.riskManagement = new RiskManagement(10000, 500, 0.01, 0.02, 0.04);
    }

    BidLevel nearTouch = state.getBidAt(0); // highest buy price 
    AskLevel farTouch = state.getAskAt(0); // lowest sell price

    if (nearTouch == null || farTouch == null) {
        logger.error("[MYALGO] Missing bid or ask level data.");
        return NoAction.NoAction;
    }

    double tradeSpread = (farTouch.price - nearTouch.price);
    logger.info("[MYALGO] The Trade spread: " + tradeSpread);
    
    spreadThreshold = 0.02 * nearTouch.price;
    double wideSpreadThreshold = 0.05 * nearTouch.price; 

    // Favorable spread condition
    if (Spread.isFavorable(state, tradeSpread, spreadThreshold, maxChildOrder)) {
        return placeBuyOrder(farTouch.price, nearTouch.quantity);
    } 
    // Wide spread condition
    else if (tradeSpread > wideSpreadThreshold) {
        logger.warn("[MYALGO] Wide spread detected. Taking no action due to high volatility.");
        return OrderAction.cancelActiveOrder(state);
    }
    // Unfavorable spread condition
    else if (Spread.isUnfavorable(state, tradeSpread, spreadThreshold, maxChildOrder)) {
        logger.info("[MYALGO] Spread is below Threshold. Waiting for favorable spread");
        return NoAction.NoAction;
    }
    // Negative spread condition
    else if (Spread.isNegative(state, tradeSpread, maxChildOrder)) {
        return handleNegativeSpread(nearTouch, state);
    }

    return NoAction.NoAction;
}

private Action placeBuyOrder(long askPrice, long askQuantity) {
    // Set the entry price for risk management
    this.entryPrice = askPrice;
    double stopLossPrice = riskManagement.calculateStopLossPrice(entryPrice);
    double takeProfitPrice = riskManagement.calculateTakeProfitPrice(entryPrice);

    logger.info(String.format("[MYALGO] Placing Buy Order of Price: %s, Stop Loss: %s, Take Profit: %s",
            askPrice, stopLossPrice, takeProfitPrice));

    return OrderAction.createBuyOrder(Side.BUY, askQuantity, askPrice);
}

private Action handleNegativeSpread(BidLevel nearTouch, SimpleAlgoState state) {
    marketPrice = nearTouch.price;
    boughtPrice = entryPrice;

    if (marketPrice > boughtPrice) {
        long bidQuantity = nearTouch.quantity;
        long bidPrice = nearTouch.price;

        this.entryPrice = bidPrice;
        double stopLossPrice = riskManagement.calculateStopLossPrice(entryPrice);
        double takeProfitPrice = riskManagement.calculateTakeProfitPrice(entryPrice);

        logger.info(String.format("[MYALGO] Placing Sell Order of Price: %s, Stop Loss: %s, Take Profit: %s",
                bidPrice, stopLossPrice, takeProfitPrice));

        return OrderAction.createSellOrder(Side.SELL, bidQuantity, bidPrice);
    }

    return NoAction.NoAction;
}
